// Apply this script to enable JaCoCo test report.
//
// This task aggregates the XML report results from all the subprojects.
// Inspired by: https://gist.github.com/aalmiray/e6f54aa4b3803be0bcac

// Required to grab dependencies for `jacocoRootReport` task.
repositories {
    mavenCentral()
}

import groovy.io.FileType

FileCollection filterOutGenerated(final FileCollection files) {
    return files.filter {
        !it.absolutePath.contains("generated")
    }
}

FileCollection filterOnlyGenerated(final FileCollection files) {
    return files.filter {
        it.absolutePath.contains("generated")
    }
}

String parseClassName(final File file, final String sourceFolderName, final String extension) {

    final def index = file.absolutePath.lastIndexOf(sourceFolderName)
    if(index > 0) {
        def filePathInFolder = file.absolutePath.substring(index + sourceFolderName.length())
        if(filePathInFolder.endsWith(extension)) {
            filePathInFolder = filePathInFolder.substring(0, filePathInFolder.length() - extension.length())

            final def className = filePathInFolder.replace('/', '.')
            return className
        } else {
            return null
        }
    } else {
        return null
    }
}

//TODO:alex.tymchenko: deal with generated `grpc`-related content.
LinkedList<String> getGeneratedClassNames() {
    final def sourceFiles = files(subprojects.sourceSets.main.java.srcDirs);
    final def generatedSourceFiles = filterOnlyGenerated(sourceFiles);

    final def generatedClassNames = new LinkedList<String>()
    generatedSourceFiles.each {final folder ->
        if(folder.exists() && folder.isDirectory()) {
            folder.eachFileRecurse(FileType.FILES) { final aFile ->
                final def name = parseClassName(aFile, "java/", ".java")
                if(name != null) {
                    println("${aFile.getAbsolutePath()} parsed into: ${name}")
                    generatedClassNames.add(name)
                } else {
                    println("${aFile.getAbsolutePath()} cannot be parsed. Potentially, it's a gRPC-generated: ${name}")
                    generatedByGrpc = parseClassName(aFile, "main/grpc/", ".java")
                    if(generatedByGrpc != null) {
                        generatedClassNames.add(generatedByGrpc)
                    }
                }
            }
        }
    }

    return generatedClassNames;
}

LinkedList<String> getGeneratedFilePaths() {

    final def sourceFiles = files(subprojects.sourceSets.main.java.srcDirs);
    final def generatedSourceFiles = filterOnlyGenerated(sourceFiles);

    final def generatedClassNames = new LinkedList<String>()
    generatedSourceFiles.each {final folder ->
        if(folder.exists() && folder.isDirectory()) {
            folder.eachFileRecurse(FileType.FILES) { final aFile ->
                final def name = parseClassName(aFile, "java/", ".java")
                if(name != null) {
                    generatedClassNames.add(aFile.getAbsolutePath())
                }
            }
        }
    }

    return generatedClassNames;
}

task filterTest {
    final def generatedClassNames = getGeneratedClassNames();

    final def collected = subprojects.sourceSets.main.output.collect {
        final def tree = fileTree(dir: it.getClassesDir(), exclude: { final details ->
            final def file = details.file
            println file.getClass()
            def className = parseClassName(file, "main/", ".class")
            if(className != null && className.contains('$')) {
                //assuming there cannot be more that a single `$`.
                className = className.split('\\$')[0]
            }
            generatedClassNames.contains(className)
        })
    }
}

task jacocoRootReport(dependsOn: subprojects.test, type: JacocoReport) {
        additionalSourceDirs = filterOutGenerated(files(subprojects.sourceSets.main.java.srcDirs))
        sourceDirectories = filterOutGenerated(files(subprojects.sourceSets.main.java.srcDirs))
        classDirectories = files(subprojects.sourceSets.main.output)
        executionData = files(subprojects.jacocoTestReport.executionData)
        reports {
            html.enabled = true
            xml.enabled = true
            csv.enabled = false
        }
        onlyIf = {
            true
        }
        doFirst {
            // In case some modules do not have the JaCoCo execution data files.
            executionData = files(executionData.findAll {
                it.exists()
            })

            println("Starting to compose an aggregate coverage report across modules.")

            final def generatedClassNames = getGeneratedClassNames();
            final def nonGeneratedClassTree = subprojects.sourceSets.main.output.collect {
                println("Filtering out the generated classes for ${it.getClassesDir()}")

                // return the filtered `fileTree` as a collected result.
                fileTree(dir: it.getClassesDir(), exclude: { final details ->
                    final def file = details.file
                    def className = parseClassName(file, "main/", ".class")
                    if (className != null && className.contains('$')) {
                        //assuming there cannot be more that a single `$`.
                        className = className.split('\\$')[0]
                    }
                    generatedClassNames.contains(className)
                })
            }
            classDirectories = files(nonGeneratedClassTree)
        }
}

check.dependsOn jacocoRootReport
